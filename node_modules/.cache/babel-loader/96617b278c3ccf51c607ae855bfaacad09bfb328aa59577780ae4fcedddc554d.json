{"ast":null,"code":"const defaultOptions = {\n  direction: 'forward',\n  speed: 2,\n  startDelay: 1000,\n  active: true,\n  breakpoints: {},\n  playOnInit: true,\n  stopOnFocusIn: true,\n  stopOnInteraction: true,\n  stopOnMouseEnter: false,\n  rootNode: null\n};\nfunction AutoScroll() {\n  let userOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let options;\n  let emblaApi;\n  let destroyed;\n  let playing = false;\n  let resume = true;\n  let timer = 0;\n  let startDelay;\n  let defaultScrollBehaviour;\n  function init(emblaApiInstance, optionsHandler) {\n    emblaApi = emblaApiInstance;\n    const {\n      mergeOptions,\n      optionsAtMedia\n    } = optionsHandler;\n    const optionsBase = mergeOptions(defaultOptions, AutoScroll.globalOptions);\n    const allOptions = mergeOptions(optionsBase, userOptions);\n    options = optionsAtMedia(allOptions);\n    if (emblaApi.scrollSnapList().length <= 1) return;\n    startDelay = options.startDelay;\n    destroyed = false;\n    defaultScrollBehaviour = emblaApi.internalEngine().scrollBody;\n    const {\n      eventStore\n    } = emblaApi.internalEngine();\n    const emblaRoot = emblaApi.rootNode();\n    const root = options.rootNode && options.rootNode(emblaRoot) || emblaRoot;\n    const container = emblaApi.containerNode();\n    emblaApi.on('pointerDown', stopScroll);\n    if (!options.stopOnInteraction) {\n      emblaApi.on('pointerUp', startScrollOnSettle);\n    }\n    if (options.stopOnMouseEnter) {\n      eventStore.add(root, 'mouseenter', () => {\n        resume = false;\n        stopScroll();\n      });\n      if (!options.stopOnInteraction) {\n        eventStore.add(root, 'mouseleave', () => {\n          resume = true;\n          startScroll();\n        });\n      }\n    }\n    if (options.stopOnFocusIn) {\n      eventStore.add(container, 'focusin', () => {\n        stopScroll();\n        emblaApi.scrollTo(emblaApi.selectedScrollSnap(), true);\n      });\n      if (!options.stopOnInteraction) {\n        eventStore.add(container, 'focusout', startScroll);\n      }\n    }\n    if (options.playOnInit) startScroll();\n  }\n  function destroy() {\n    emblaApi.off('pointerDown', stopScroll).off('pointerUp', startScrollOnSettle).off('settle', onSettle);\n    stopScroll();\n    destroyed = true;\n    playing = false;\n  }\n  function startScroll() {\n    if (destroyed || playing) return;\n    if (!resume) return;\n    emblaApi.emit('autoScroll:play');\n    const engine = emblaApi.internalEngine();\n    const {\n      ownerWindow\n    } = engine;\n    timer = ownerWindow.setTimeout(() => {\n      engine.scrollBody = createAutoScrollBehaviour(engine);\n      engine.animation.start();\n    }, startDelay);\n    playing = true;\n  }\n  function stopScroll() {\n    if (destroyed || !playing) return;\n    emblaApi.emit('autoScroll:stop');\n    const engine = emblaApi.internalEngine();\n    const {\n      ownerWindow\n    } = engine;\n    engine.scrollBody = defaultScrollBehaviour;\n    ownerWindow.clearTimeout(timer);\n    timer = 0;\n    playing = false;\n  }\n  function onSettle() {\n    if (resume) startScroll();\n    emblaApi.off('settle', onSettle);\n  }\n  function startScrollOnSettle() {\n    emblaApi.on('settle', onSettle);\n  }\n  function createAutoScrollBehaviour(engine) {\n    const {\n      location,\n      previousLocation,\n      offsetLocation,\n      target,\n      scrollTarget,\n      index,\n      indexPrevious,\n      limit: {\n        reachedMin,\n        reachedMax,\n        constrain\n      },\n      options: {\n        loop\n      }\n    } = engine;\n    const directionSign = options.direction === 'forward' ? -1 : 1;\n    const noop = () => self;\n    let bodyVelocity = 0;\n    let scrollDirection = 0;\n    let rawLocation = location.get();\n    let rawLocationPrevious = 0;\n    let hasSettled = false;\n    function seek(timeStep) {\n      const fixedDeltaTimeSeconds = timeStep / 1000;\n      let directionDiff = 0;\n      previousLocation.set(location);\n      bodyVelocity = directionSign * options.speed * 55;\n      rawLocation += bodyVelocity;\n      location.add(bodyVelocity * fixedDeltaTimeSeconds);\n      target.set(location);\n      directionDiff = rawLocation - rawLocationPrevious;\n      scrollDirection = Math.sign(directionDiff);\n      rawLocationPrevious = rawLocation;\n      const currentIndex = scrollTarget.byDistance(0, false).index;\n      if (index.get() !== currentIndex) {\n        indexPrevious.set(index.get());\n        index.set(currentIndex);\n        emblaApi.emit('select');\n      }\n      const reachedEnd = options.direction === 'forward' ? reachedMin(offsetLocation.get()) : reachedMax(offsetLocation.get());\n      if (!loop && reachedEnd) {\n        hasSettled = true;\n        const constrainedLocation = constrain(location.get());\n        location.set(constrainedLocation);\n        target.set(location);\n        stopScroll();\n      }\n      return self;\n    }\n    const self = {\n      direction: () => scrollDirection,\n      duration: () => -1,\n      velocity: () => bodyVelocity,\n      settled: () => hasSettled,\n      seek,\n      useBaseFriction: noop,\n      useBaseDuration: noop,\n      useFriction: noop,\n      useDuration: noop\n    };\n    return self;\n  }\n  function play(startDelayOverride) {\n    if (typeof startDelayOverride !== 'undefined') {\n      startDelay = startDelayOverride;\n    }\n    resume = true;\n    startScroll();\n  }\n  function stop() {\n    if (playing) stopScroll();\n  }\n  function reset() {\n    if (playing) {\n      stopScroll();\n      startScrollOnSettle();\n    }\n  }\n  function isPlaying() {\n    return playing;\n  }\n  const self = {\n    name: 'autoScroll',\n    options: userOptions,\n    init,\n    destroy,\n    play,\n    stop,\n    reset,\n    isPlaying\n  };\n  return self;\n}\nAutoScroll.globalOptions = undefined;\nexport { AutoScroll as default };","map":{"version":3,"names":["defaultOptions","direction","speed","startDelay","active","breakpoints","playOnInit","stopOnFocusIn","stopOnInteraction","stopOnMouseEnter","rootNode","AutoScroll","userOptions","arguments","length","undefined","options","emblaApi","destroyed","playing","resume","timer","defaultScrollBehaviour","init","emblaApiInstance","optionsHandler","mergeOptions","optionsAtMedia","optionsBase","globalOptions","allOptions","scrollSnapList","internalEngine","scrollBody","eventStore","emblaRoot","root","container","containerNode","on","stopScroll","startScrollOnSettle","add","startScroll","scrollTo","selectedScrollSnap","destroy","off","onSettle","emit","engine","ownerWindow","setTimeout","createAutoScrollBehaviour","animation","start","clearTimeout","location","previousLocation","offsetLocation","target","scrollTarget","index","indexPrevious","limit","reachedMin","reachedMax","constrain","loop","directionSign","noop","self","bodyVelocity","scrollDirection","rawLocation","get","rawLocationPrevious","hasSettled","seek","timeStep","fixedDeltaTimeSeconds","directionDiff","set","Math","sign","currentIndex","byDistance","reachedEnd","constrainedLocation","duration","velocity","settled","useBaseFriction","useBaseDuration","useFriction","useDuration","play","startDelayOverride","stop","reset","isPlaying","name"],"sources":["/Users/nevinadacakmak/Desktop/Projects/PersonalWebsite/node_modules/embla-carousel-auto-scroll/src/components/Options.ts","/Users/nevinadacakmak/Desktop/Projects/PersonalWebsite/node_modules/embla-carousel-auto-scroll/src/components/AutoScroll.ts"],"sourcesContent":["import { CreateOptionsType } from 'embla-carousel'\n\nexport type OptionsType = CreateOptionsType<{\n  direction: 'forward' | 'backward'\n  speed: number\n  startDelay: number\n  playOnInit: boolean\n  stopOnFocusIn: boolean\n  stopOnInteraction: boolean\n  stopOnMouseEnter: boolean\n  rootNode: ((emblaRoot: HTMLElement) => HTMLElement | null) | null\n}>\n\nexport const defaultOptions: OptionsType = {\n  direction: 'forward',\n  speed: 2,\n  startDelay: 1000,\n  active: true,\n  breakpoints: {},\n  playOnInit: true,\n  stopOnFocusIn: true,\n  stopOnInteraction: true,\n  stopOnMouseEnter: false,\n  rootNode: null\n}\n","import { OptionsType, defaultOptions } from './Options'\nimport {\n  CreatePluginType,\n  OptionsHandlerType,\n  EmblaCarouselType,\n  EngineType,\n  ScrollBodyType\n} from 'embla-carousel'\n\ndeclare module 'embla-carousel' {\n  interface EmblaPluginsType {\n    autoScroll: AutoScrollType\n  }\n\n  interface EmblaEventListType {\n    autoScrollPlay: 'autoScroll:play'\n    autoScrollStop: 'autoScroll:stop'\n  }\n}\n\nexport type AutoScrollType = CreatePluginType<\n  {\n    play: (delay?: number) => void\n    stop: () => void\n    reset: () => void\n    isPlaying: () => boolean\n  },\n  OptionsType\n>\n\nexport type AutoScrollOptionsType = AutoScrollType['options']\n\nfunction AutoScroll(userOptions: AutoScrollOptionsType = {}): AutoScrollType {\n  let options: OptionsType\n  let emblaApi: EmblaCarouselType\n  let destroyed: boolean\n  let playing = false\n  let resume = true\n  let timer = 0\n  let startDelay: number\n  let defaultScrollBehaviour: ScrollBodyType\n\n  function init(\n    emblaApiInstance: EmblaCarouselType,\n    optionsHandler: OptionsHandlerType\n  ): void {\n    emblaApi = emblaApiInstance\n\n    const { mergeOptions, optionsAtMedia } = optionsHandler\n    const optionsBase = mergeOptions(defaultOptions, AutoScroll.globalOptions)\n    const allOptions = mergeOptions(optionsBase, userOptions)\n    options = optionsAtMedia(allOptions)\n\n    if (emblaApi.scrollSnapList().length <= 1) return\n\n    startDelay = options.startDelay\n    destroyed = false\n    defaultScrollBehaviour = emblaApi.internalEngine().scrollBody\n\n    const { eventStore } = emblaApi.internalEngine()\n    const emblaRoot = emblaApi.rootNode()\n    const root = (options.rootNode && options.rootNode(emblaRoot)) || emblaRoot\n    const container = emblaApi.containerNode()\n\n    emblaApi.on('pointerDown', stopScroll)\n\n    if (!options.stopOnInteraction) {\n      emblaApi.on('pointerUp', startScrollOnSettle)\n    }\n\n    if (options.stopOnMouseEnter) {\n      eventStore.add(root, 'mouseenter', () => {\n        resume = false\n        stopScroll()\n      })\n\n      if (!options.stopOnInteraction) {\n        eventStore.add(root, 'mouseleave', () => {\n          resume = true\n          startScroll()\n        })\n      }\n    }\n\n    if (options.stopOnFocusIn) {\n      eventStore.add(container, 'focusin', () => {\n        stopScroll()\n        emblaApi.scrollTo(emblaApi.selectedScrollSnap(), true)\n      })\n\n      if (!options.stopOnInteraction) {\n        eventStore.add(container, 'focusout', startScroll)\n      }\n    }\n\n    if (options.playOnInit) startScroll()\n  }\n\n  function destroy(): void {\n    emblaApi\n      .off('pointerDown', stopScroll)\n      .off('pointerUp', startScrollOnSettle)\n      .off('settle', onSettle)\n    stopScroll()\n    destroyed = true\n    playing = false\n  }\n\n  function startScroll(): void {\n    if (destroyed || playing) return\n    if (!resume) return\n    emblaApi.emit('autoScroll:play')\n\n    const engine = emblaApi.internalEngine()\n    const { ownerWindow } = engine\n\n    timer = ownerWindow.setTimeout(() => {\n      engine.scrollBody = createAutoScrollBehaviour(engine)\n      engine.animation.start()\n    }, startDelay)\n\n    playing = true\n  }\n\n  function stopScroll(): void {\n    if (destroyed || !playing) return\n    emblaApi.emit('autoScroll:stop')\n\n    const engine = emblaApi.internalEngine()\n    const { ownerWindow } = engine\n\n    engine.scrollBody = defaultScrollBehaviour\n    ownerWindow.clearTimeout(timer)\n    timer = 0\n\n    playing = false\n  }\n\n  function onSettle(): void {\n    if (resume) startScroll()\n    emblaApi.off('settle', onSettle)\n  }\n\n  function startScrollOnSettle(): void {\n    emblaApi.on('settle', onSettle)\n  }\n\n  function createAutoScrollBehaviour(engine: EngineType): ScrollBodyType {\n    const {\n      location,\n      previousLocation,\n      offsetLocation,\n      target,\n      scrollTarget,\n      index,\n      indexPrevious,\n      limit: { reachedMin, reachedMax, constrain },\n      options: { loop }\n    } = engine\n    const directionSign = options.direction === 'forward' ? -1 : 1\n    const noop = (): ScrollBodyType => self\n\n    let bodyVelocity = 0\n    let scrollDirection = 0\n    let rawLocation = location.get()\n    let rawLocationPrevious = 0\n    let hasSettled = false\n\n    function seek(timeStep: number): ScrollBodyType {\n      const fixedDeltaTimeSeconds = timeStep / 1000\n      let directionDiff = 0\n\n      previousLocation.set(location)\n\n      bodyVelocity = directionSign * options.speed * 55\n      rawLocation += bodyVelocity\n      location.add(bodyVelocity * fixedDeltaTimeSeconds)\n      target.set(location)\n\n      directionDiff = rawLocation - rawLocationPrevious\n      scrollDirection = Math.sign(directionDiff)\n      rawLocationPrevious = rawLocation\n\n      const currentIndex = scrollTarget.byDistance(0, false).index\n\n      if (index.get() !== currentIndex) {\n        indexPrevious.set(index.get())\n        index.set(currentIndex)\n        emblaApi.emit('select')\n      }\n\n      const reachedEnd =\n        options.direction === 'forward'\n          ? reachedMin(offsetLocation.get())\n          : reachedMax(offsetLocation.get())\n\n      if (!loop && reachedEnd) {\n        hasSettled = true\n        const constrainedLocation = constrain(location.get())\n        location.set(constrainedLocation)\n        target.set(location)\n        stopScroll()\n      }\n\n      return self\n    }\n\n    const self: ScrollBodyType = {\n      direction: () => scrollDirection,\n      duration: () => -1,\n      velocity: () => bodyVelocity,\n      settled: () => hasSettled,\n      seek,\n      useBaseFriction: noop,\n      useBaseDuration: noop,\n      useFriction: noop,\n      useDuration: noop\n    }\n    return self\n  }\n\n  function play(startDelayOverride?: number): void {\n    if (typeof startDelayOverride !== 'undefined') {\n      startDelay = startDelayOverride\n    }\n    resume = true\n    startScroll()\n  }\n\n  function stop(): void {\n    if (playing) stopScroll()\n  }\n\n  function reset(): void {\n    if (playing) {\n      stopScroll()\n      startScrollOnSettle()\n    }\n  }\n\n  function isPlaying(): boolean {\n    return playing\n  }\n\n  const self: AutoScrollType = {\n    name: 'autoScroll',\n    options: userOptions,\n    init,\n    destroy,\n    play,\n    stop,\n    reset,\n    isPlaying\n  }\n  return self\n}\n\ndeclare namespace AutoScroll {\n  let globalOptions: AutoScrollOptionsType | undefined\n}\n\nAutoScroll.globalOptions = undefined\n\nexport default AutoScroll\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}